# РОЗДІЛ 4 ІМПЛЕМЕНТАЦІЯ

## 4.1 Загальна структура програмного продукту

Розроблений програмний продукт для оцінювання доступності вебінтерфейсів реалізовано як багатокомпонентну систему, що складається з трьох основних модулів: серверного додатку (backend), вебінтерфейсу та браузерного розширення. Така архітектура забезпечує гнучкість використання системи в різних сценаріях та дозволяє користувачам обирати найбільш зручний спосіб взаємодії залежно від їхніх потреб та технічних можливостей.

Серверний додаток виступає центральним компонентом системи та відповідає за виконання усіх обчислювальних операцій, пов'язаних з аналізом доступності. Він реалізований на мові програмування Python з використанням асинхронного вебфреймворку FastAPI, який забезпечує високу продуктивність обробки запитів та підтримку сучасних стандартів розробки REST API. Застосування асинхронного підходу до програмування дозволяє ефективно обробляти паралельні запити від різних клієнтів без блокування основного потоку виконання, що є критично важливим для системи, яка виконує ресурсомісткі операції завантаження та аналізу вебсторінок.

Вебінтерфейс призначений для користувачів, які потребують разового або періодичного аналізу доступності вебресурсів без необхідності встановлення додаткового програмного забезпечення. Він реалізований як односторінковий застосунок (Single Page Application), що взаємодіє з серверним додатком через HTTP API. Користувач має змогу ввести URL досліджуваного вебсайту, ініціювати процес аналізу та отримати структурований звіт із детальними метриками доступності, візуалізацією результатів та конкретними рекомендаціями щодо усунення виявлених проблем.

Браузерне розширення розроблено для інтеграції функціоналу оцінювання доступності безпосередньо в середовище браузера користувача. Воно забезпечує можливість аналізу будь-якої відкритої у браузері вебсторінки одним кліком, що значно підвищує зручність використання системи при постійній роботі з веб-ресурсами, зокрема в процесі розробки або тестування інтерфейсів. Розширення створено з дотриманням специфікації Manifest V3 для забезпечення сумісності з сучасними версіями браузерів Google Chrome, Microsoft Edge та Mozilla Firefox.

Архітектурно система побудована за клієнт-серверною моделлю з чіткою сепарацією відповідальності між компонентами. Всі обчислювально складні операції, такі як завантаження вебсторінок з використанням безголового браузера, виконання JavaScript-коду сторінок, запуск автоматизованих тестів доступності за допомогою бібліотеки axe-core, виконуються на серверній частині. Клієнтські компоненти відповідають виключно за збір мінімально необхідних даних (URL або HTML-контент сторінки), відправку запитів до API та відображення отриманих результатів в зручному для користувача форматі.

Така архітектура має низку важливих переваг. По-перше, централізація логіки аналізу на сервері забезпечує єдиний джерело істини (single source of truth) для всіх алгоритмів оцінювання, що спрощує підтримку коду та виключає можливість розбіжностей у результатах між різними клієнтськими додатками. По-друге, серверна обробка дозволяє використовувати потужні інструменти, такі як Playwright для емуляції повноцінного браузерного середовища, що було б неможливо реалізувати безпосередньо в браузерному розширенні через обмеження безпеки. По-третє, така архітектура полегшує масштабування системи: за необхідності обробки великої кількості запитів можна розгорнути кілька екземплярів серверного додатку за балансувальником навантаження.

Взаємодія між компонентами системи здійснюється через REST API з використанням JSON як формату обміну даними. Для забезпечення коректної роботи з різними джерелами запитів застосовано механізм CORS (Cross-Origin Resource Sharing), що дозволяє вебінтерфейсу та браузерному розширенню звертатися до API сервера незалежно від доменів, на яких вони розміщені. Всі ендпоінти API автоматично документуються з використанням специфікації OpenAPI (Swagger), що спрощує інтеграцію системи з іншими сервісами та дозволяє розробникам швидко ознайомитися з доступними методами та форматами даних.

У додатку А наведено повну діаграму архітектури системи з зображенням взаємодії між компонентами та потоками даних. Детальний опис структури каталогів проекту та призначення основних модулів представлено в додатку Б.

## 4.2 Основний модуль AccessibilityEvaluator

### 4.2.1 Класи та інтерфейси модуля

Основний модуль системи оцінювання доступності реалізовано у вигляді класу `AccessibilityEvaluator`, який інкапсулює всю логіку координації процесу аналізу та інтеграції результатів від спеціалізованих підмодулів. Клас побудовано згідно з принципами об'єктно-орієнтованого програмування, зокрема принципом єдиної відповідальності (Single Responsibility Principle), де кожен підклас відповідає за розрахунок метрик конкретної підвластивості доступності.

Архітектура класу передбачає композицію чотирьох спеціалізованих аналізаторів метрик:
- `PerceptibilityMetrics` для оцінювання перцептивності (UAC-1.1-G);
- `OperabilityMetrics` для оцінювання керованості (UAC-1.2-G);
- `UnderstandabilityMetrics` для оцінювання зрозумілості (UAC-1.3-G);
- `LocalizationMetrics` для оцінювання локалізації (UAC-2.1-S).

Кожен із цих класів реалізує спільний інтерфейс з асинхронним методом `calculate_metrics()`, який приймає на вхід словник `page_data` з даними проаналізованої сторінки та повертає словник з обчисленими значеннями відповідних метрик. Така уніфікація інтерфейсів дозволяє легко розширювати систему новими типами метрик без необхідності модифікації основного модуля.

Для збору даних з вебсторінок використовується допоміжний клас `WebScraper`, який інкапсулює логіку взаємодії з безголовим браузером Playwright. Цей клас відповідає за завантаження сторінки, очікування завершення виконання JavaScript-коду, збір інформації про структуру DOM-дерева, інтерактивні елементи, медіа-контент, форми введення даних, а також запуск аналізатора axe-core безпосередньо в контексті браузера. Результати роботи `WebScraper` формуються у вигляді структурованого словника, який надалі передається аналізаторам метрик.

Окремим компонентом є клас `ScoreCalculator`, що реалізує математичні формули для агрегації індивідуальних метрик у підскори (subscores) для кожної підвластивості та обчислення фінального показника доступності згідно з ваговою моделлю, розробленою у попередньому розділі дослідження. Цей клас також містить методи для визначення якісного рівня доступності на основі кваліметричної шкали Фібоначчі та генерації текстових описів отриманих результатів.

Структура основного модуля передбачає чітку сепарацію етапів обробки даних:
1. Збір даних про вебсторінку (web scraping);
2. Розрахунок індивідуальних метрик доступності;
3. Агрегація метрик у підскори;
4. Обчислення фінального показника;
5. Генерація рекомендацій та детального звіту.

Така послідовність операцій дозволяє забезпечити модульність системи, де кожен етап може бути незалежно протестований, оптимізований або замінений на альтернативну реалізацію без впливу на інші компоненти.

У додатку В наведено UML-діаграму класів основного модуля з відображенням залежностей між компонентами та основних методів кожного класу.

### 4.2.2 Алгоритм обчислення метрик і вагових коефіцієнтів

Процес обчислення метрик доступності побудовано на основі результатів автоматизованого аналізу вебсторінок з використанням бібліотеки axe-core — промислового стандарту для перевірки відповідності веб-контенту вимогам WCAG. Ця бібліотека реалізує понад 90 правил перевірки, що охоплюють всі рівні відповідності стандарту WCAG 2.1 (A, AA, AAA) та надає структуровані результати у форматі JSON з детальною інформацією про виявлені порушення та успішно пройдені перевірки.

Розрахунок метрики альтернативного тексту для зображень (UAC-1.1.1-G) здійснюється шляхом аналізу результатів правил `image-alt`, `input-image-alt` та `area-alt` з axe-core. Для кожного правила підраховується кількість елементів, що пройшли перевірку (`passes`), та кількість елементів з виявленими порушеннями (`violations`). Метрика обчислюється як відношення кількості коректних елементів до загальної кількості перевірених елементів. У випадку відсутності зображень на сторінці метрика приймає значення 1.0, що відповідає відсутності проблем у даному аспекті доступності.

Для забезпечення коректної роботи в різних сценаріях, зокрема при аналізі HTML-контенту, отриманого безпосередньо з браузерного розширення, реалізовано механізм запасного аналізу (fallback analysis). У випадку, коли axe-core не може виконати перевірку через технічні обмеження контексту виконання, система здійснює альтернативний аналіз HTML-розмітки з використанням парсера BeautifulSoup. Такий підхід дозволяє отримати базову оцінку навіть за відсутності повноцінного браузерного контексту, хоча точність такої оцінки може бути дещо нижчою через неможливість врахування динамічно згенерованого контенту та computed styles.

Обчислення метрики контрастності кольорів (UAC-1.1.2-G) базується на результатах правил `color-contrast` та `color-contrast-enhanced` з axe-core. Ці правила перевіряють відповідність контрастного співвідношення між кольором тексту та фону мінімальним вимогам WCAG: 4.5:1 для звичайного тексту та 3:1 для великого тексту (критерій успіху 1.4.3 рівня AA) або 7:1 та 4.5:1 відповідно для розширеного рівня AAA (критерій 1.4.6). Аналізатор враховує також випадки, коли текст розміщено на градієнтному або зображеному фоні, де точне обчислення контрасту може бути ускладнено. Метрика розраховується аналогічно до метрики альтернативного тексту — як частка елементів з достатнім контрастом від загальної кількості текстових елементів.

Метрика доступності медіа-контенту (UAC-1.1.3-G) оцінює наявність субтитрів для відео та аудіоописів, необхідних для користувачів з порушеннями слуху та зору відповідно. Аналізатор перевіряє наявність HTML5 елементів `<track>` з атрибутами `kind="subtitles"`, `kind="captions"` або `kind="descriptions"` в межах тегів `<video>` та `<audio>`. Для вбудованих відеоплеєрів з платформ YouTube та Vimeo здійснюється евристична перевірка наявності параметрів субтитрів в URL відео (`cc_load_policy=1`, `captions=1`). У випадку виявлення таких параметрів робиться припущення про наявність субтитрів, хоча це не гарантує їх фактичну присутність, оскільки автор відео міг їх не надати.

Метрики керованості розраховуються на основі аналізу можливості навігації за допомогою клавіатури та логічності структури заголовків. Для оцінки клавіатурної навігації (UAC-1.2.1-G) система перевіряє доступність фокусу для всіх інтерактивних елементів, таких як посилання, кнопки, поля введення, що реалізується через аналіз результатів axe-core правил `focusable-order`, `tabindex` та інших релевантних перевірок. Структурована навігація (UAC-1.2.2-G) оцінюється шляхом аналізу ієрархії заголовків: перевіряється наявність головного заголовка `<h1>`, відсутність пропусків рівнів заголовків (наприклад, переходу від `<h2>` безпосередньо до `<h4>`), унікальність головного заголовка та логічна послідовність структури документа.

Метрики зрозумілості включають оцінку якості інструкцій до форм (UAC-1.3.1-G), наявності допомоги при введенні даних (UAC-1.3.2-G) та коректності обробки помилок (UAC-1.3.3-G). Ці метрики розраховуються на основі динамічного тестування форм, що виконується за допомогою модуля `FormTester`. Тестер виконує послідовність дій: виявлення всіх форм на сторінці, спробу відправлення порожніх форм для перевірки валідації, введення некоректних даних для тестування повідомлень про помилки, аналіз наявності атрибутів `aria-describedby`, `aria-invalid`, `aria-errormessage` та елементів `<label>`. Результати цих перевірок агрегуються в кількісні метрики, що відображають частку форм з належною підтримкою користувача.

Метрика локалізації (UAC-2.1-S) обчислюється на основі атрибута `lang` кореневого елемента HTML та наявності мовних альтернатив сторінки. Система аналізує значення атрибута та перевіряє його відповідність стандарту ISO 639-1. Для оцінки застосовується вагова модель, де українська та англійська мови отримують найвищі коефіцієнти значущості, німецька та французька — середні, а інші мови — найнижчі. Розрахунок фінального значення метрики здійснюється як зважена сума наявних мовних версій згідно з формулою, наведеною у підрозділі 2.2.4.

Агрегація індивідуальних метрик у підскори для кожної підвластивості виконується з використанням зважених середніх значень. Коефіцієнти ваги для метрик в межах кожної підвластивості визначено експертним методом з урахуванням їх відносного впливу на загальну доступність:

```python
perceptibility = (
    alt_text * 0.5 +
    contrast * 0.5 +
    media_accessibility * 0.4
) / 1.4
```

Подібні формули застосовуються для інших підвластивостей (детальні формули наведено в додатку Г). Фінальний показник доступності розраховується згідно з формулою, розробленою у розділі 2:

```python
final_score = 0.6 * (0.3 * perceptibility +
                     0.3 * operability +
                     0.4 * understandability) +
              0.4 * localization
```

Ця формула відображає вагову модель, де основні аспекти доступності (перцептивність, керованість, зрозумілість) отримують сумарну вагу 0.6, а локалізація — 0.4, що відповідає структурі стандарту ISO 25023, де локалізація виділена в окрему характеристику якості.

Детальний опис алгоритмів розрахунку кожної метрики з наведенням псевдокоду та прикладів вхідних даних представлено в додатку Д.

### 4.2.3 Формування рекомендацій для користувача

Генерація практичних рекомендацій щодо покращення доступності є важливою складовою функціоналу системи, оскільки числові метрики самі по собі не надають розробникам конкретних вказівок щодо усунення виявлених проблем. Модуль формування рекомендацій реалізовано у вигляді методу `generate_recommendations()` класу `AccessibilityEvaluator`, який аналізує отримані значення метрик та генерує структурований список рекомендацій з пріоритизацією за рівнем критичності.

Рекомендації класифікуються за трьома рівнями пріоритету: високий (high), середній (medium) та низький (low). Рівень пріоритету визначається на основі значення відповідної метрики: якщо метрика нижча за 0.5, рекомендація отримує високий пріоритет, якщо нижча за 0.7 — середній, а вище 0.7 — низький. Така градація дозволяє користувачам сфокусуватися на найбільш критичних проблемах, які мають найсуттєвіший вплив на доступність вебресурсу.

Кожна рекомендація містить чотири основні компоненти: категорію (перцептивність, керованість, зрозумілість або локалізація), рівень пріоритету, текстовий опис проблеми та конкретні дії для її усунення, а також посилання на відповідний критерій успіху WCAG 2.1. Наприклад, для метрики альтернативного тексту з низьким значенням система генерує рекомендацію наступного вигляду:

```
Категорія: Перцептивність
Пріоритет: Високий
Рекомендація: На сторінці виявлено зображення без альтернативного тексту.
Додайте атрибут alt до всіх інформативних зображень з описом їх змісту.
Для декоративних зображень використовуйте порожній атрибут alt="".
WCAG: Критерій успіху 1.1.1 Non-text Content (рівень A)
```

Текст рекомендацій формується на основі заздалегідь визначених шаблонів для кожного типу проблеми, з динамічною підстановкою кількісних показників там, де це доречно. Наприклад, для проблем з контрастністю рекомендація може включати кількість елементів з недостатнім контрастом та конкретні значення контрастних співвідношень, що не відповідають стандарту.

Для формування більш детальних рекомендацій система використовує результати axe-core, які містять не лише інформацію про порушення правил, але й конкретні HTML-селектори проблемних елементів, їх атрибути та текстові описи причин невідповідності. Ця інформація дозволяє генерувати рекомендації, що вказують на конкретні елементи сторінки, які потребують виправлення, що значно спрощує роботу розробників з усунення проблем.

У випадках, коли система виявляє системні проблеми, що стосуються багатьох елементів одного типу, рекомендації формулюються на рівні загальних принципів організації контенту. Наприклад, якщо на сторінці відсутня логічна структура заголовків, система рекомендує переглянути загальну структуру документа та організувати заголовки відповідно до семантичної ієрархії змісту, а не лише вказує на конкретні проблемні елементи.

Особливу увагу приділено формулюванню рекомендацій для проблем зрозумілості, оскільки вони часто вимагають не лише технічних змін у коді, але й перегляду текстового контенту та логіки взаємодії з користувачем. Для таких випадків рекомендації включають приклади належного формулювання інструкцій, підказок та повідомлень про помилки, що відповідають найкращим практикам UX-дизайну для інклюзивних інтерфейсів.

Згенеровані рекомендації сортуються спочатку за пріоритетом (від високого до низького), а потім за категорією, що забезпечує зручну структуру звіту, де найбільш критичні проблеми відображаються на початку списку. Такий підхід до пріоритизації допомагає користувачам системи ефективно планувати роботу з покращення доступності, фокусуючись спочатку на аспектах, що мають найбільший вплив на користувацький досвід осіб з обмеженими можливостями.

Приклади сформованих рекомендацій для різних типів виявлених проблем з детальним поясненням логіки їх генерації наведено в додатку Е.

## 4.3 Модулі збору та обробки даних

Модуль збору даних реалізовано у вигляді класу `WebScraper`, який забезпечує комплексне отримання інформації про структуру та властивості досліджуваної вебсторінки. Основою цього модуля є бібліотека Playwright — сучасний інструмент для автоматизації браузерів, розроблений компанією Microsoft як наступник Puppeteer. На відміну від простих HTTP-клієнтів, Playwright забезпечує повноцінну емуляцію роботи браузера, включаючи виконання JavaScript-коду, рендеринг CSS та обробку асинхронних операцій завантаження контенту.

Процес збору даних розпочинається з ініціалізації безголового браузера (headless browser) на основі движка Chromium. Вибір Chromium обумовлений його високою сумісністю з сучасними веб-стандартами та широкою підтримкою API для інспекції DOM-структури. Після ініціалізації браузера створюється новий контекст сторінки з налаштованими таймаутами: 60 секунд для операцій навігації та завантаження ресурсів, що є достатнім для більшості вебсайтів, але запобігає безкінечному очікуванню у випадку недоступності ресурсу.

Навігація до цільової сторінки здійснюється з використанням стратегії очікування `networkidle`, яка гарантує, що всі мережеві запити завершено і сторінка перебуває у стабільному стані. Така стратегія є критично важливою для коректної роботи аналізаторів, оскільки багато сучасних вебсайтів використовують асинхронне завантаження контенту через AJAX-запити, і аналіз частково завантаженої сторінки призвів би до неточних результатів. У випадку невдачі з `networkidle` система автоматично повторює спробу з менш суворою стратегією `domcontentloaded`, що дозволяє обробляти сторінки зі складною логікою завантаження ресурсів.

Після успішного завантаження сторінки модуль виконує серію операцій збору даних:

1. Отримання повного HTML-контенту сторінки методом `page.content()`, який повертає серіалізоване представлення DOM-дерева після виконання всіх скриптів.

2. Збір інформації про інтерактивні елементи через виконання CSS-селекторів для кнопок, посилань, полів введення, елементів з атрибутом `tabindex` та інших компонентів, з якими користувач може взаємодіяти. Для кожного елемента зберігаються його тип, стан видимості, доступність для фокусування та значення ARIA-атрибутів.

3. Аналіз текстових елементів з отриманням їх computed styles, що включають кольори тексту та фону, розмір шрифту та товщину. Ці дані є необхідними для подальшого розрахунку контрастних співвідношень.

4. Виявлення медіа-елементів (зображення, відео, аудіо) з детальною інформацією про їх атрибути: джерела контенту, альтернативні тексти, наявність субтитрів у вигляді `<track>` елементів, мімтипи та інші метадані.

5. Збір даних про форми на сторінці, включаючи структуру полів, типи введення, наявність міток (labels), обов'язковість заповнення, атрибути валідації та асоційовані повідомлення про помилки.

Окремої уваги заслуговує інтеграція бібліотеки axe-core, яка виконується шляхом ін'єкції JavaScript-файлу безпосередньо в контекст браузера за допомогою методу `page.add_script_tag()`. Після завантаження скрипта система ініціює виконання аналізу командою `axe.run()` через механізм `page.evaluate()`, що дозволяє виконати JavaScript-код в контексті сторінки та отримати результати назад у Python-середовище. Результати axe-core містять структуровану інформацію про виявлені порушення доступності, успішно пройдені перевірки, неповні тести (де аналізатор не зміг автоматично визначити відповідність) та неприкладні правила. Ця інформація зберігається у складі загального словника `page_data` для подальшого використання аналізаторами метрик.

Для забезпечення надійності роботи модуль реалізує обробку типових помилок: таймаути навігації, помилки мережі, відсутність дозволу на завантаження певних ресурсів. У випадку виникнення критичної помилки система генерує структуроване виключення з детальним описом проблеми, що дозволяє вищим рівням застосунку коректно обробити ситуацію та надати користувачу зрозуміле повідомлення про причини невдачі аналізу.

Модуль обробки даних представлено класом `FormTester`, який відповідає за динамічне тестування форм введення даних на предмет наявності належної підтримки користувача. Цей модуль виконує симуляцію типових користувацьких дій: спроби відправлення порожніх форм, введення некоректних даних у поля з певними вимогами до формату (email, телефон, дата), тестування реакції форм на різні типи помилок. Результати цих тестів використовуються для розрахунку метрик зрозумілості.

Детальна специфікація форматів даних, що повертаються модулями збору інформації, з прикладами JSON-структур наведена в додатку Ж.

## 4.4 Оцінювання метрик доступності

Процес оцінювання кожної метрики доступності реалізовано у вигляді окремих класів, що дозволяє забезпечити модульність системи та незалежність розрахунків різних аспектів доступності. Кожен клас успадковується від абстрактного базового класу `BaseMetrics`, який визначає спільний інтерфейс та базові методи, що використовуються всіма аналізаторами.

Клас `PerceptibilityMetrics` інкапсулює логіку оцінювання трьох складових перцептивності. Метод `calculate_alt_text_metric()` реалізує алгоритм, що спочатку намагається використати результати axe-core для правил `image-alt`, `input-image-alt` та `area-alt`. Система підраховує кількість елементів у секціях `passes` (елементи, що пройшли перевірку) та `violations` (елементи з виявленими порушеннями) для кожного правила. Загальна кількість зображень обчислюється як сума цих двох значень, а метрика — як відношення кількості коректних зображень до загальної кількості.

У випадку, коли axe-core не виявив жодного зображення (що може трапитися при аналізі HTML-контенту без повноцінного браузерного контексту), активується механізм запасного аналізу. Він використовує парсер BeautifulSoup для пошуку всіх тегів `<img>` у HTML-розмітці та перевіряє наявність атрибута `alt` у кожного з них. Зображення з наявним атрибутом `alt` (навіть якщо він порожній, що допустимо для декоративних зображень) вважаються коректними, а зображення без цього атрибута — проблемними. Така логіка відповідає критерію успіху WCAG 1.1.1, який вимагає наявності текстової альтернативи для всього нетекстового контенту.

Метод `calculate_contrast_metric()` реалізує оцінювання контрастності на основі результатів правил axe-core `color-contrast` та `color-contrast-enhanced`. Система аналізує значення контрастних співвідношень, що повертає axe-core для кожного текстового елемента, та порівнює їх з мінімальними вимогами WCAG: 4.5:1 для звичайного тексту (менше 18pt для нормального шрифту або 14pt для жирного) та 3:1 для великого тексту. Елементи, що не відповідають цим вимогам, потрапляють до секції `violations` з детальною інформацією про фактичне та необхідне значення контрасту, а також кольори переднього плану та фону у форматі RGB або HEX.

Аналогічно до метрики альтернативного тексту, для контрастності реалізовано запасний механізм аналізу, який активується при відсутності результатів від axe-core. Оскільки точне обчислення контрастності вимагає знання computed styles елементів, що неможливо отримати з простого HTML, запасний аналізатор використовує евристичний підхід: він ідентифікує всі текстові елементи у розмітці та повертає консервативну оцінку 0.8, припускаючи, що приблизно 80% елементів мають достатній контраст. Така оцінка не є точною, але дає базове уявлення про наявність потенційних проблем з контрастністю.

Метод `calculate_media_accessibility_metric()` оцінює доступність відео-контенту шляхом аналізу наявності субтитрів та аудіоописів. Для нативних HTML5 відео (теги `<video>`) система перевіряє наявність вкладених елементів `<track>` з атрибутами `kind="subtitles"`, `kind="captions"` або `kind="descriptions"`. Для вбудованих відеоплеєрів YouTube та Vimeo аналізатор застосовує евристичну перевірку URL відео на наявність параметрів, що вказують на увімкнені субтитри: `cc_load_policy=1` для YouTube або `texttrack=1` для Vimeo. Метрика обчислюється як відношення кількості відео з виявленими засобами доступності до загальної кількості відео на сторінці.

Клас `OperabilityMetrics` відповідає за оцінку керованості через метрики клавіатурної навігації та структурованості контенту. Метод `calculate_keyboard_navigation_metric()` аналізує доступність інтерактивних елементів для взаємодії через клавіатуру. Система ідентифікує всі потенційно інтерактивні елементи (посилання, кнопки, поля введення, елементи з обробниками подій) та перевіряє, чи можуть вони отримати фокус клавіатури. Це здійснюється через аналіз результатів axe-core правил `focusable-order`, `focusable-content`, `focus-order-semantics` та `tabindex`. Елементи з негативним `tabindex` (крім `-1` для програмного фокусування) або елементи, що неможливо досягти через логічну навігацію Tab, вважаються проблемними.

Метод `calculate_structured_navigation_metric()` оцінює логічність структури заголовків документа. Аналізатор будує дерево заголовків на основі тегів `<h1>` – `<h6>` та перевіряє дотримання наступних правил: наявність рівно одного головного заголовка `<h1>`, відсутність пропусків рівнів (наприклад, `<h2>` не може слідувати безпосередньо після `<h4>`), логічна вкладеність секцій. Кожне порушення цих правил знижує оцінку метрики пропорційно до кількості та серйозності проблем.

Клас `UnderstandabilityMetrics` реалізує оцінку зрозумілості через три метрики, пов'язані з формами. Метод `calculate_instruction_clarity_metric()` перевіряє наявність чітких інструкцій для кожного поля форми. Система аналізує присутність елементів `<label>`, асоційованих з полями через атрибут `for`, а також атрибутів `aria-label`, `aria-labelledby` та `aria-describedby`, які забезпечують альтернативні способи надання текстових описів. Форми, де всі поля мають належні мітки та інструкції, отримують максимальну оцінку.

Метод `calculate_input_assistance_metric()` оцінює наявність механізмів допомоги користувачу при введенні даних. До таких механізмів належать: атрибут `autocomplete` для автоматичного заповнення полів на основі раніше введених даних, атрибут `pattern` для вказівки очікуваного формату введення, атрибут `placeholder` для демонстрації прикладу коректного значення, атрибути `min`, `max`, `minlength`, `maxlength` для вказівки допустимих діапазонів значень. Чим більше таких механізмів застосовано у формах сайту, тим вища оцінка метрики.

Метод `calculate_error_support_metric()` перевіряє якість обробки помилок у формах. Аналізатор використовує модуль `FormTester` для виконання тестових відправлень форм з некоректними даними та перевіряє, чи система надає зрозумілі повідомлення про помилки. Оцінюються такі аспекти: чи відображаються повідомлення про помилки поруч з проблемними полями, чи використовуються атрибути `aria-invalid` та `aria-errormessage` для забезпечення доступності повідомлень для скрінрідерів, чи містять повідомлення конкретні вказівки щодо виправлення помилки, а не лише загальні фрази типу "Невірні дані".

Клас `LocalizationMetrics` реалізує найпростішу з метрик — оцінку локалізації. Метод `calculate_localization_metric()` аналізує атрибут `lang` кореневого елемента `<html>` та перевіряє його значення на відповідність стандарту ISO 639-1. Для виявлення альтернативних мовних версій система шукає елементи `<link rel="alternate" hreflang="...">` у секції `<head>` документа, які вказують на наявність перекладів сторінки. Кожна виявлена мова отримує ваговий коефіцієнт згідно з моделлю, розробленою у розділі 2, а фінальна метрика обчислюється як зважена сума.

Всі методи розрахунку метрик реалізовано як асинхронні (`async def`) для забезпечення можливості їх паралельного виконання, що суттєво прискорює загальний процес аналізу, особливо для сторінок з великою кількістю елементів. Координація виконання асинхронних операцій здійснюється через вбудовані механізми Python `asyncio`, зокрема `asyncio.gather()` для паралельного очікування завершення кількох корутин.

Детальні алгоритми розрахунку кожної метрики з наведенням блок-схем та прикладів проміжних обчислень представлено в додатку З.

## 4.5 Інтерфейс та взаємодія з користувачем

### 4.5.1 REST API

Програмний інтерфейс додатку (API) реалізовано згідно з архітектурним стилем REST (Representational State Transfer), що забезпечує стандартизований спосіб взаємодії між клієнтськими додатками та серверною логікою оцінювання доступності. Використання REST API дозволяє легко інтегрувати систему оцінювання з іншими інструментами та сервісами, такими як системи безперервної інтеграції (CI/CD), автоматизовані тестувальні фреймворки або сторонні платформи моніторингу якості вебсайтів.

API побудовано з використанням фреймворку FastAPI, який надає автоматичну валідацію вхідних даних на основі Python type hints та Pydantic моделей, автоматичну генерацію документації у форматах OpenAPI (Swagger) та ReDoc, а також вбудовану підтримку асинхронних обробників запитів. Останнє є критично важливим для системи оцінювання доступності, оскільки процес аналізу вебсторінки може тривати від кількох секунд до хвилини залежно від складності сайту, і блокування потоку виконання на цей час було б неприйнятним для продуктивності сервера.

API системи включає наступні основні ендпоінти:

`POST /api/evaluate` — ініціює процес оцінювання доступності вебсторінки за наданим URL. Тіло запиту має містити JSON-об'єкт з полем `url`, значенням якого є повний URL досліджуваної сторінки. Ендпоінт повертає структурований JSON-об'єкт з результатами аналізу, що включає фінальний показник доступності, значення всіх метрик та підскорів, список згенерованих рекомендацій з пріоритетами, а також детальний аналіз з інформацією про конкретні проблемні елементи.

`POST /api/evaluate-html` — альтернативний ендпоінт для оцінювання доступності на основі безпосередньо наданого HTML-контенту замість URL. Цей ендпоінт призначений для інтеграції з браузерним розширенням, яке може передавати поточний стан DOM-дерева активної вкладки браузера. Тіло запиту містить поля `html_content` з HTML-розміткою та опціональні `base_url` і `title` для контекстної інформації.

`POST /api/report` — генерує повний HTML-звіт про доступність на основі раніше отриманих результатів аналізу. Цей ендпоінт приймає JSON з результатами оцінювання та повертає відрендерений HTML-документ з детальною візуалізацією всіх аспектів доступності, графіками, таблицями проблемних елементів та рекомендаціями. Такий звіт може бути збережений користувачем для документування стану доступності або надісланий зацікавленим сторонам.

`GET /api/health` — перевірка стану сервера, що повертає просту JSON-відповідь з інформацією про версію API та готовність системи до обробки запитів. Цей ендпоінт використовується клієнтськими додатками для діагностики доступності сервера перед відправленням ресурсомістких запитів на аналіз.

Для забезпечення коректної роботи з різними джерелами запитів API сконфігуровано з підтримкою CORS (Cross-Origin Resource Sharing). Це дозволяє вебінтерфейсу, розміщеному на іншому домені, та браузерному розширенню виконувати запити до API без обмежень з боку політики безпеки браузера. Конфігурація CORS дозволяє запити з будь-яких джерел (`allow_origins=["*"]`), що зручно для розробки та тестування, але в продакшн-середовищі рекомендується обмежити список дозволених доменів для підвищення безпеки.

Всі ендпоінти API використовують строгу типізацію даних через Pydantic моделі. Для вхідних даних визначено моделі `URLRequest`, `HTMLRequest` та `ReportRequest`, які автоматично валідують структуру та типи полів у запитах. Для вихідних даних використовується модель `EvaluationResponse`, що гарантує узгодженість формату відповідей незалежно від внутрішньої логіки обробки. Такий підхід запобігає типовим помилкам, пов'язаним з некоректними форматами даних, та забезпечує самодокументованість API.

Обробка помилок в API реалізована через механізм виключень FastAPI. У випадку виникнення помилки під час аналізу (наприклад, недоступність URL, таймаут завантаження, внутрішня помилка аналізатора) система генерує HTTP-відповідь з відповідним кодом статусу (4xx для помилок клієнта, 5xx для серверних помилок) та структурованим JSON-об'єктом з детальним описом проблеми. Це дозволяє клієнтським додаткам коректно реагувати на різні типи помилок та надавати користувачам зрозумілі повідомлення.

Автоматично згенерована документація API доступна за шляхом `/docs` (інтерфейс Swagger UI) та `/redoc` (інтерфейс ReDoc). Ці інтерфейси надають інтерактивну документацію з описом всіх ендпоінтів, форматів запитів та відповідей, а також дозволяють виконувати тестові запити безпосередньо з браузера без необхідності використання сторонніх інструментів типу Postman або curl.

Детальна специфікація всіх ендпоінтів API з прикладами запитів та відповідей у форматі OpenAPI наведена в додатку И.

### 4.5.2 Веб-інтерфейс

Вебінтерфейс системи реалізовано як односторінковий застосунок, що надає користувачам зручний спосіб оцінювання доступності вебсайтів без необхідності встановлення додаткового програмного забезпечення. Інтерфейс побудовано з використанням сучасних вебтехнологій: HTML5 для структури, CSS3 для стилізації та JavaScript (ES6+) для логіки взаємодії.

Архітектура вебінтерфейсу базується на шаблонізаторі Jinja2, що дозволяє розділити статичну розмітку та динамічно згенерований контент. Основний шаблон `index.html` містить структуру головної сторінки з формою введення URL, областю відображення результатів та навігаційними елементами. Використання шаблонізатора замість вбудованого HTML у Python-код забезпечує кращу підтримуваність та дозволяє дизайнерам працювати з інтерфейсом незалежно від програмістів backend.

Користувацький інтерфейс побудовано згідно з принципами прогресивного покращення (progressive enhancement): базовий функціонал доступний навіть при вимкненому JavaScript, а інтерактивні елементи додаються як покращення досвіду. Це забезпечує максимальну доступність самого інтерфейсу системи, що є важливим з точки зору консистентності — інструмент для перевірки доступності повинен сам бути доступним для всіх категорій користувачів.

Основний робочий процес у вебінтерфейсі організовано наступним чином:

1. Користувач вводить URL вебсайту для аналізу у текстове поле та натискає кнопку "Аналізувати".

2. JavaScript-код виконує валідацію введеного URL на коректність формату, перевіряючи наявність протоколу (http/https) та домену.

3. При успішній валідації відображається індикатор завантаження, а кнопка аналізу стає неактивною для запобігання повторним відправленням запиту.

4. Виконується асинхронний HTTP-запит до ендпоінту `/api/evaluate` з використанням Fetch API, що є сучасним стандартом для мережевих операцій у браузері.

5. Під час виконання запиту користувач бачить анімований індикатор прогресу та повідомлення про поточний стан аналізу.

6. При отриманні відповіді від сервера результати обробляються JavaScript-кодом та відображаються у вигляді інтерактивного звіту.

Візуалізація результатів реалізована з використанням комбінації різних елементів інтерфейсу. Фінальний показник доступності відображається як велика числова оцінка з кольоровим індикатором якості: зелений для високих показників, жовтий для середніх та червоний для низьких. Під головною оцінкою розміщено чотири картки (cards) з підскорами для кожної підвластивості доступності, кожна з яких містить числове значення, текстовий опис та прогрес-бар для візуального представлення.

Детальні метрики організовано у вигляді розгортаємих секцій (accordions), що дозволяє користувачу фокусуватися на конкретних аспектах доступності. Кожна секція містить назву метрики, її значення, короткий опис того, що вона вимірює, та список конкретних проблемних елементів, якщо такі виявлено. Для проблемних елементів відображаються CSS-селектори, фрагменти HTML-коду та описи виявлених порушень.

Рекомендації щодо покращення доступності відображаються у вигляді списку з візуальною індикацією пріоритету: високопріоритетні рекомендації виділено червоним кольором та розміщено на початку списку, середньопріоритетні — жовтим, низькопріоритетні — зеленим. Кожна рекомендація містить короткий заголовок, детальний опис проблеми та конкретні кроки для її усунення, а також кліка

бельне посилання на відповідний критерій WCAG для отримання додаткової інформації.

Вебінтерфейс включає функціонал експорту результатів у форматі HTML-звіту, який користувач може зберегти локально або надіслати зацікавленим сторонам. Експорт реалізовано через запит до ендпоінту `/api/report`, який генерує самодостатній HTML-документ з вбудованими стилями та всією необхідною інформацією. Такий звіт може бути відкритий у будь-якому браузері без необхідності доступу до сервера системи.

Стилізація вебінтерфейсу виконана з дотриманням сучасних тенденцій UI/UX дизайну: використання білого простору для покращення читабельності, консистентна кольорова схема, адаптивний дизайн для коректного відображення на різних розмірах екранів (десктоп, планшет, смартфон). Всі інтерактивні елементи мають чіткі візуальні стани (normal, hover, focus, active) та доступні для навігації через клавіатуру, що забезпечує доступність інтерфейсу згідно з критеріями WCAG 2.1 рівня AA.

Приклади скріншотів вебінтерфейсу з різними станами (початковий стан, процес аналізу, відображення результатів) наведено в додатку К.

### 4.5.3 Браузерне розширення

Браузерне розширення розроблено як зручний інструмент для швидкого аналізу доступності будь-якої відкритої у браузері вебсторінки без необхідності копіювання URL та переходу до вебінтерфейсу системи. Розширення реалізовано згідно зі специфікацією Manifest V3 — новим стандартом для розширень браузера, що забезпечує покращену безпеку, продуктивність та конфіденційність порівняно з попередньою версією.

Архітектура розширення побудована за мінімалістичним принципом: всю обчислювальну логіку винесено на сервер, а розширення виконує лише функції інтерфейсу користувача та посередника між браузером і API сервера. Така архітектура має низку переваг: менше споживання пам'яті браузера, відсутність дублювання коду між різними компонентами системи, простота оновлення логіки аналізу без необхідності публікації нових версій розширення.

Основні компоненти розширення:

**Popup інтерфейс** — невеликий інтерактивний вікно, що відкривається при кліку на іконку розширення у панелі інструментів браузера. Інтерфейс реалізовано у вигляді HTML-сторінки (`popup.html`) з асоційованими стилями (`popup.css`) та логікою (`popup.js`). Розміри popup обмежені для зручності використання: ширина 400 пікселів, висота адаптується до контенту, але не перевищує 600 пікселів.

**Клас AccessibilityPopup** — центральний JavaScript-клас, що інкапсулює всю логіку розширення. Клас відповідає за ініціалізацію інтерфейсу, обробку користувацьких дій, комунікацію з API сервера, збереження результатів аналізу в локальному сховищі браузера та відображення результатів у popup.

Робочий процес розширення організовано наступним чином:

1. При відкритті popup виконується метод `init()`, який ініціалізує налаштування розширення зі сховища `chrome.storage.sync`, перевіряє доступність сервера через запит до ендпоінту `/api/health` та завантажує раніше збережені результати для поточної вкладки, якщо вони існують.

2. Користувач натискає кнопку "Аналізувати сторінку", що активує метод `analyzeCurrentPage()`.

3. Метод отримує інформацію про активну вкладку через API `chrome.tabs.query()` та перевіряє, чи сторінка доступна для аналізу (деякі внутрішні сторінки браузера, такі як `chrome://` або `about:`, недоступні для розширень через обмеження безпеки).

4. Виконується скрипт у контексті активної вкладки через API `chrome.scripting.executeScript()`, який витягує поточний стан DOM-дерева разом з усіма динамічно згенерованими елементами. Це критично важливо, оскільки багато сучасних вебсайтів використовують JavaScript-фреймворки (React, Vue, Angular) для генерації контенту, і аналіз лише початкового HTML дав би неповні результати.

5. Отриманий HTML-контент обробляється для конвертації відносних URL в абсолютні. Це необхідно, оскільки при передачі HTML на сервер втрачається контекст базового URL, і зображення, стилі та скрипти з відносними шляхами не змогли б завантажитися. Конвертація виконується через API `URL` браузера, який коректно обробляє всі типи відносних посилань (відносно кореня домену, відносно поточної сторінки, з навігацією на рівень вище тощо).

6. Сформований пакет даних (HTML-контент, базовий URL, заголовок сторінки) відправляється на ендпоінт `/api/evaluate-html` через асинхронний HTTP-запит.

7. Під час обробки запиту сервером popup відображає індикатор завантаження та повідомлення про поточний етап аналізу.

8. Отримані результати зберігаються в локальному сховищі `chrome.storage.local` з ключем, що містить хеш URL сторінки, що дозволяє швидко завантажувати раніше отримані результати при повторному відкритті popup для тієї ж сторінки без необхідності повторного аналізу.

9. Результати відображаються в popup аналогічно до вебінтерфейсу: головна оцінка, підскори, детальні метрики та рекомендації.

Розширення реалізує механізм кешування результатів з версіонуванням структури даних. При зміні формату збережених даних (наприклад, додаванні нових полів до результатів аналізу) система автоматично очищує застарілий кеш через перевірку версії даних. Це запобігає помилкам, пов'язаним з несумісністю форматів, що могли б виникнути після оновлення розширення.

Для забезпечення зручності використання розширення підтримує експорт результатів у HTML-звіт аналогічно до вебінтерфейсу. Функція експорту викликає ендпоінт `/api/report` з отриманими раніше результатами та зберігає згенерований HTML-файл через API `chrome.downloads`, що активує стандартний діалог завантаження файлів браузера.

Налаштування розширення (URL сервера API, мова інтерфейсу, рівень деталізації звітів) зберігаються в синхронізованому сховищі `chrome.storage.sync`, що дозволяє автоматично синхронізувати їх між різними пристроями користувача при використанні облікового запису браузера.

Детальна структура файлів розширення з описом призначення кожного компонента наведена в додатку Л. Приклади комунікації розширення з API сервера з наведенням послідовності запитів та відповідей представлено в додатку М.

## 4.6 Тестування та відлагодження

Процес тестування розробленої системи оцінювання доступності включав кілька рівнів перевірки коректності функціонування: модульне тестування окремих компонентів, інтеграційне тестування взаємодії між модулями, системне тестування повного циклу аналізу на реальних вебсайтах та тестування зручності використання інтерфейсів.

Модульне тестування реалізовано з використанням фреймворку pytest — стандартного інструменту для тестування Python-додатків. Створено набір тестів для кожного класу аналізаторів метрик, що перевіряють коректність обчислень на заздалегідь підготовлених тестових даних. Наприклад, для класу `PerceptibilityMetrics` розроблено тести, що перевіряють обчислення метрики альтернативного тексту на різних комбінаціях вхідних даних: сторінки без зображень, сторінки з коректними зображеннями, сторінки з проблемними зображеннями, змішані випадки. Кожен тест включає assertion про очікуване значення метрики з точністю до третього знаку після коми.

Особливу увагу приділено тестуванню граничних випадків та обробки помилок. Створено тести, що перевіряють поведінку системи при аналізі некоректних URL, недоступних сторінок, сторінок з таймаутом завантаження, сторінок з некоректною HTML-розміткою. Для кожного такого випадку визначено очікувану поведінку системи: генерація відповідного виключення з детальним описом проблеми або повернення результатів з позначкою про часткову невдачу аналізу певних аспектів.

Інтеграційне тестування зосереджено на перевірці коректної взаємодії між компонентами системи. Розроблено тести, що імітують повний цикл роботи: від отримання запиту через API до повернення результатів. Ці тести використовують тестові веб-сервери з заздалегідь підготовленими HTML-сторінками, що містять відомі проблеми доступності, та перевіряють, чи система коректно виявляє ці проблеми та генерує відповідні рекомендації.

Для тестування взаємодії з безголовим браузером Playwright застосовано підхід з використанням моків (mocks) — об'єктів-замінників, що імітують поведінку реальних компонентів. Це дозволило прискорити виконання тестів, оскільки запуск повноцінного браузера для кожного тесту був би занадто ресурсомістким. Однак окремо створено набір інтеграційних тестів, що використовують реальний браузер, для перевірки коректності роботи в реальних умовах.

Системне тестування проводилося на вибірці з 50 реальних вебсайтів різної складності: від простих статичних сторінок до складних веб-застосунків з динамічним контентом. Для кожного сайту виконано аналіз доступності та порівняно отримані результати з результатами аналізу іншими інструментами (WAVE, axe DevTools, Lighthouse) для валідації коректності обчислень. Виявлено, що результати розробленої системи узгоджуються з результатами існуючих інструментів для автоматично перевірюваних аспектів доступності, а для аспектів, що вимагають ручної перевірки (наприклад, змістовність альтернативних текстів), система коректно позначає їх як такі, що потребують додаткового дослідження.

У процесі тестування виявлено та усунуто низку проблем:

1. **Проблема з відносними URL в HTML від браузерного розширення**: Початкова реалізація не конвертувала відносні посилання в абсолютні, що призводило до неможливості завантаження ресурсів при аналізі на сервері. Рішення полягало у додаванні етапу обробки HTML перед відправкою, що конвертує всі відносні URL через API `URL` браузера.

2. **Проблема з таймаутами для повільних сайтів**: Деякі вебсайти завантажувалися довше за встановлений таймаут 30 секунд, що призводило до помилок аналізу. Таймаут збільшено до 60 секунд, а також додано логіку повторних спроб з менш суворими умовами очікування завантаження.

3. **Проблема з обробкою сторінок з великою кількістю елементів**: Аналіз сторінок з тисячами елементів (наприклад, інтернет-магазинів з великими каталогами) призводив до значного споживання пам'яті. Оптимізовано алгоритми для обробки даних порціями та додано обмеження на кількість аналізованих елементів кожного типу (наприклад, максимум 1000 текстових елементів для аналізу контрастності).

Відлагодження системи здійснювалося з використанням комбінації інструментів: вбудованого дебагера Python (pdb), логування на різних рівнях деталізації (DEBUG, INFO, WARNING, ERROR), а також інструментів розробника браузера для аналізу роботи клієнтських компонентів. Застосовано структуроване логування з використанням бібліотеки logging, що дозволяє конфігурувати рівень деталізації логів залежно від середовища (розробка, тестування, продакшн).

Для полегшення діагностики проблем у продакшн-середовищі реалізовано механізм детального логування всіх етапів аналізу з відмітками часу, що дозволяє ідентифікувати вузькі місця у продуктивності та виявляти причини помилок на основі логів. Кожен HTTP-запит до API отримує унікальний ідентифікатор, що прослідковується через всі лог-записи, пов'язані з обробкою цього запиту, що спрощує аналіз логів при одночасній обробці багатьох запитів.

Детальний опис тестових сценаріїв з прикладами вхідних даних та очікуваних результатів наведено в додатку Н. Приклади лог-файлів з різних етапів роботи системи представлено в додатку О.

## 4.7 Розгортання

Розгортання розробленої системи оцінювання доступності можливе в кількох конфігураціях залежно від вимог до навантаження, доступності та безпеки. Базова конфігурація передбачає розгортання на одному сервері, де виконується як API-сервер, так і обслуговування статичних файлів вебінтерфейсу. Для продакшн-середовища з високим навантаженням рекомендується розподілена конфігурація з окремими інстансами для API та балансувальником навантаження.

Базовий процес розгортання включає наступні етапи:

1. **Підготовка серверного середовища**: Необхідно встановити Python версії 3.9 або новіше, Node.js для запуску axe-core, а також системні залежності для Playwright (браузер Chromium та його залежності). Для Ubuntu/Debian це виконується командами встановлення пакетів через apt, для інших операційних систем — відповідними пакетними менеджерами.

2. **Встановлення Python-залежностей**: Використовуючи pip та файл `requirements.txt`, встановлюються всі необхідні бібліотеки: FastAPI, Playwright, BeautifulSoup, Pydantic та інші. Рекомендується використовувати віртуальне середовище (venv або conda) для ізоляції залежностей проекту від системних пакетів.

3. **Ініціалізація Playwright**: Після встановлення бібліотеки Playwright необхідно виконати команду завантаження браузерів, що скачує та налаштовує Chromium для використання у headless режимі.

4. **Встановлення axe-core**: Через npm встановлюється пакет axe-core, JavaScript-файл якого буде використовуватися для ін'єкції в контекст браузера при аналізі сторінок.

5. **Конфігурація змінних середовища**: Створюється файл `.env` з конфігураційними параметрами: порт для API-сервера, рівень логування, максимальні таймаути, обмеження на розмір HTML-контенту тощо.

6. **Запуск API-сервера**: Виконується Python-скрипт `start_server.py`, який ініціалізує FastAPI додаток з використанням ASGI-сервера Uvicorn. Для продакшн-середовища рекомендується використовувати процес-менеджер (наприклад, systemd на Linux або Supervisor) для забезпечення автоматичного перезапуску сервера у випадку збоїв.

7. **Налаштування зворотного проксі**: Для продакшн-розгортання рекомендується розмістити API-сервер за зворотним проксі-сервером (Nginx або Apache), який відповідатиме за обробку SSL/TLS шифрування, стиснення відповідей, кешування статичних файлів та захист від типових атак (наприклад, обмеження кількості запитів з одного IP).

Конфігурація Nginx для розгортання включає налаштування проксіювання запитів до API-сервера, обслуговування статичних файлів безпосередньо з файлової системи без проксіювання до Python-додатку, налаштування SSL-сертифікатів (рекомендується використовувати Let's Encrypt для безкоштовних сертифікатів), а також заголовків безпеки (Content-Security-Policy, X-Frame-Options тощо).

Для браузерного розширення процес розгортання відрізняється залежно від цільової платформи:

**Chrome Web Store**: Необхідно створити обліковий запис розробника, підготувати пакет розширення (ZIP-архів з усіма файлами), заповнити метадані (назва, опис, скріншоти, іконки) та подати на перевірку. Процес перевірки зазвичай займає від кількох днів до тижня. Після схвалення розширення стає доступним для встановлення користувачами через магазин.

**Firefox Add-ons**: Процес аналогічний до Chrome, але використовується платформа addons.mozilla.org. Mozilla має більш суворі вимоги до безпеки коду розширень, зокрема заборонено використання eval() та динамічного виконання коду.

**Ручне встановлення**: Для розробки та тестування розширення можна встановлювати напряму з локальної файлової системи через режим розробника в налаштуваннях браузера. Це дозволяє швидко тестувати зміни без необхідності проходити процес публікації.

Моніторинг працездатності системи в продакшн-середовищі рекомендується здійснювати через комбінацію інструментів: логування з агрегацією у централізованому сховищі логів (наприклад, ELK Stack або Loki), метрики продуктивності (кількість запитів, середній час обробки, кількість помилок) через систему моніторингу (Prometheus + Grafana), сповіщення про критичні помилки через інтеграцію з системами алертингу (PagerDuty, Opsgenie).

Для забезпечення високої доступності рекомендується розгортання кількох інстансів API-сервера за балансувальником навантаження (HAProxy, Nginx Plus або хмарний балансувальник у випадку використання cloud-платформ). Оскільки система є stateless (не зберігає стан між запитами), масштабування горизонтально не вимагає складної координації між інстансами.

Детальні інструкції з розгортання для різних операційних систем та конфігурацій з прикладами скриптів автоматизації наведено в додатку П. Приклади конфігураційних файлів для Nginx, systemd та Docker наведено в додатку Р.

---

**Висновки до розділу 4**

У даному розділі детально описано реалізацію програмної системи для комплексного оцінювання доступності вебінтерфейсів. Розроблену архітектуру побудовано за принципом чіткої сепарації відповідальності між компонентами, що забезпечує модульність, підтримуваність та можливість незалежного розвитку окремих частин системи.

Основний модуль `AccessibilityEvaluator` реалізує координацію процесу аналізу через композицію спеціалізованих аналізаторів метрик для кожної підвластивості доступності. Застосування асинхронного програмування дозволило досягти високої продуктивності при обробці ресурсомістких операцій завантаження та аналізу вебсторінок.

Інтеграція промислового стандарту axe-core для автоматизованої перевірки відповідності WCAG забезпечує високу точність виявлення проблем доступності при збереженні можливості розширення системи власними евристичними алгоритмами для аспектів, що не покриваються автоматичними перевірками.

Реалізовано три варіанти інтерфейсу користувача — REST API, вебінтерфейс та браузерне розширення — що дозволяє користувачам обирати найбільш зручний спосіб взаємодії з системою залежно від їхніх потреб та технічних можливостей. Всі інтерфейси забезпечують доступ до однакової функціональності через єдиний серверний backend, що гарантує консистентність результатів.

Проведене тестування підтвердило коректність обчислень метрик та стабільність роботи системи на різноманітних вебсайтах. Виявлені в процесі тестування проблеми були успішно усунуті, а система оптимізована для ефективної роботи навіть з ресурсомісткими сторінками.

Розроблені інструкції з розгортання дозволяють встановити систему як у простій конфігурації для індивідуального використання, так і у розподіленій конфігурації для обслуговування великої кількості користувачів у продакшн-середовищі.
